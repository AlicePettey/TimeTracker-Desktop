// electron/main.js

const { app, BrowserWindow, ipcMain, Tray, Menu, nativeImage, powerMonitor, shell } = require('electron');
const path = require('path');
const os = require('os');
const { v4: uuidv4 } = require('uuid');

// Handle ICU data path for packaged apps (keep from your working file)
if (app.isPackaged) {
  const fs = require('fs');
  const icuDataPath = path.join(process.resourcesPath, 'icudtl.dat');
  if (fs.existsSync(icuDataPath)) {
    process.env.ICU_DATA = icuDataPath;
  }
}

// electron-store with fallback (keep)
let Store;
try {
  Store = require('electron-store');
} catch (e) {
  console.error('Failed to load electron-store:', e);
  Store = class {
    constructor(opts) {
      this.data = opts?.defaults || {};
    }
    get(key, defaultValue) {
      const keys = key.split('.');
      let value = this.data;
      for (const k of keys) value = value?.[k];
      return value !== undefined ? value : defaultValue;
    }
    set(key, value) {
      if (typeof key === 'object') {
        Object.assign(this.data, key);
      } else {
        const keys = key.split('.');
        let obj = this.data;
        for (let i = 0; i < keys.length - 1; i++) {
          if (!obj[keys[i]]) obj[keys[i]] = {};
          obj = obj[keys[i]];
        }
        obj[keys[keys.length - 1]] = value;
      }
    }
  };
}

const store = new Store({
  name: 'timetracker-data',
  defaults: {
    activities: [],
    settings: {
      idleThreshold: 300,
      minActivityDuration: 120,
      syncEnabled: true,
      switchDebounceSeconds: 7,

      // IMPORTANT: Set these in the Desktop UI settings
      syncUrl: '',          // https://xxxxx.supabase.co
      syncToken: '',        // desktop sync token generated by web app
      syncAnonKey: '',      // SUPABASE ANON KEY fallback for packaged app

      startOnBoot: true,
      minimizeToTray: true,
      trackingEnabled: true,
      autoUpdate: true,
      allowPrerelease: false,

      // Auto-sync settings
      syncInterval: 15,
      syncOnClose: true,
      syncOnIdle: true,
      autoSyncEnabled: true,
      syncOnStartup: true,

      batchSize: 50,
      retryFailedSyncs: true,
      maxRetryAttempts: 3
    },
    syncQueue: [],
    lastSyncTime: null,
    failedSyncAttempts: 0,
    deviceId: null
  }
});

let autoSyncTimer = null;
let isIdle = false;

let mainWindow = null;
let tray = null;
let tracker = null;
let appUpdater = null;
let isQuitting = false;

// Lazy load tracker/updater (keep)
async function loadTracker() {
  try {
    return require('./tracker');
  } catch (error) {
    console.error('Failed to load tracker:', error);
    return null;
  }
}
async function loadUpdater() {
  try {
    return require('./updater');
  } catch (error) {
    console.error('Failed to load updater:', error);
    return null;
  }
}

// Device id
function getDeviceId() {
  let deviceId = store.get('deviceId');
  if (!deviceId) {
    deviceId = uuidv4();
    store.set('deviceId', deviceId);
  }
  return deviceId;
}

// -----------------------------
// Window + navigation safety
// -----------------------------
function getIconPath() {
  const fs = require('fs');
  const assetsDir = path.join(__dirname, 'assets');

  const iconOptions = process.platform === 'win32'
    ? ['icon.ico', 'icon.png']
    : process.platform === 'darwin'
      ? ['icon.icns', 'icon.png']
      : ['icon.png'];

  for (const iconName of iconOptions) {
    const iconPath = path.join(assetsDir, iconName);
    try {
      if (fs.existsSync(iconPath)) return iconPath;
    } catch {}
  }
  return undefined;
}

function createWindow() {
  mainWindow = new BrowserWindow({
    width: 420,
    height: 700,
    minWidth: 380,
    minHeight: 500,
    frame: false,
    transparent: false,
    resizable: true,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js'),
      sandbox: false
    },
    icon: getIconPath(),
    show: false
  });

  // ✅ THIS is the correct production load target for your Electron UI
  // (because your renderer build lives in electron/renderer/)
  mainWindow.loadFile(path.join(__dirname, 'renderer', 'index.html'));

  // Helpful diagnostics for “white window”
  mainWindow.webContents.on('did-fail-load', (event, errorCode, errorDescription, validatedURL) => {
    console.error('DID_FAIL_LOAD', { errorCode, errorDescription, validatedURL });
  });
  mainWindow.webContents.on('render-process-gone', (event, details) => {
    console.error('RENDER_PROCESS_GONE', details);
  });

  // Block popups inside Electron, open in browser instead
  mainWindow.webContents.setWindowOpenHandler(({ url }) => {
    if (/^https?:\/\//i.test(url)) shell.openExternal(url);
    return { action: 'deny' };
  });

  // Prevent cross-origin navigations from hijacking the window
  mainWindow.webContents.on('will-navigate', (event, url) => {
    const current = mainWindow.webContents.getURL();
    let sameOrigin = false;
    try {
      sameOrigin = new URL(url).origin === new URL(current).origin;
    } catch {}
    if (!sameOrigin && /^https?:\/\//i.test(url)) {
      event.preventDefault();
      shell.openExternal(url);
    }
  });

  mainWindow.once('ready-to-show', async () => {
    mainWindow.show();

    appUpdater = await loadUpdater();
    if (appUpdater) {
      appUpdater.setMainWindow(mainWindow);

      const settings = store.get('settings');
      if (settings.autoUpdate) {
        appUpdater.startPeriodicUpdateChecks(4);
      }
    }
  });

  mainWindow.on('close', async (event) => {
    if (!isQuitting && store.get('settings.minimizeToTray')) {
      event.preventDefault();
      mainWindow.hide();
      return false;
    }
  });

  mainWindow.on('closed', () => {
    mainWindow = null;
  });
}

// -----------------------------
// Tray (keep your existing approach)
// -----------------------------
function createDefaultTrayIcon() {
  const size = 16;
  const canvas = Buffer.alloc(size * size * 4);
  for (let i = 0; i < size * size; i++) {
    const o = i * 4;
    canvas[o] = 59;
    canvas[o + 1] = 130;
    canvas[o + 2] = 246;
    canvas[o + 3] = 255;
  }
  return nativeImage.createFromBuffer(canvas, { width: size, height: size });
}

function updateTrayMenu() {
  if (!tray) return;

  const isTracking = tracker ? tracker.isTracking : false;
  const contextMenu = Menu.buildFromTemplate([
    {
      label: 'Show TimeTracker',
      click: () => {
        if (mainWindow) {
          mainWindow.show();
          mainWindow.focus();
        }
      }
    },
    { type: 'separator' },
    {
      label: isTracking ? 'Pause Tracking' : 'Start Tracking',
      click: () => {
        if (tracker) {
          if (isTracking) tracker.pause();
          else tracker.start();
        }
        updateTrayMenu();
      }
    },
    { type: 'separator' },
    { label: 'Sync Now', click: () => syncActivities() },
    {
      label: 'Check for Updates',
      click: () => {
        if (appUpdater) appUpdater.checkForUpdates(false);
      }
    },
    { type: 'separator' },
    {
      label: 'Quit',
      click: () => {
        isQuitting = true;
        app.quit();
      }
    }
  ]);

  tray.setContextMenu(contextMenu);
  tray.setToolTip(`TimeTracker Desktop - ${isTracking ? 'Tracking' : 'Paused'}`);
}

function createTray() {
  const fs = require('fs');
  const iconPath = path.join(__dirname, 'assets', 'tray-icon.png');

  let trayIcon;
  try {
    if (fs.existsSync(iconPath)) trayIcon = nativeImage.createFromPath(iconPath);
  } catch {}

  if (!trayIcon || trayIcon.isEmpty()) trayIcon = createDefaultTrayIcon();
  if (!trayIcon.isEmpty()) trayIcon = trayIcon.resize({ width: 16, height: 16 });

  tray = new Tray(trayIcon);
  updateTrayMenu();
  tray.setToolTip('TimeTracker Desktop');

  tray.on('click', () => {
    if (!mainWindow) return;
    if (mainWindow.isVisible()) mainWindow.hide();
    else {
      mainWindow.show();
      mainWindow.focus();
    }
  });
}

// -----------------------------
// Auto-sync / idle hooks
// -----------------------------
function startAutoSyncTimer() {
  stopAutoSyncTimer();

  const settings = store.get('settings');
  if (!settings.autoSyncEnabled || !settings.syncEnabled) return;

  const intervalMs = settings.syncInterval * 60 * 1000;
  autoSyncTimer = setInterval(async () => {
    const s = store.get('settings');
    if (s.autoSyncEnabled && s.syncEnabled) await syncActivities();
  }, intervalMs);
}

function stopAutoSyncTimer() {
  if (autoSyncTimer) {
    clearInterval(autoSyncTimer);
    autoSyncTimer = null;
  }
}

function handleIdleSync() {
  const settings = store.get('settings');
  if (settings.syncOnIdle && settings.syncEnabled && !isIdle) {
    isIdle = true;
    syncActivities();
  }
}
function handleIdleEnd() {
  isIdle = false;
}

async function syncOnClose() {
  const settings = store.get('settings');
  if (settings.syncOnClose && settings.syncEnabled) {
    await syncActivities();
  }
}
async function syncOnStartup() {
  const settings = store.get('settings');
  if (settings.syncOnStartup && settings.syncEnabled) {
    setTimeout(async () => {
      await syncActivities();
    }, 5000);
  }
}

// -----------------------------
// Tracker init (keep)
// -----------------------------
async function initializeTracker() {
  const ActivityTracker = await loadTracker();
  if (!ActivityTracker) return;

  const settings = store.get('settings') || {};

  tracker = new ActivityTracker({
    idleThreshold: settings.idleThreshold ?? 300,
    minActivityDuration: settings.minActivityDuration ?? 60,
    getSystemIdleSeconds: () => powerMonitor.getSystemIdleTime(),
    switchDebounceSeconds: settings.switchDebounceSeconds ?? 7,
    excludeApps: settings.excludeApps ?? [],
    excludeTitles: settings.excludeTitles ?? [],

    onActivity: (activity) => {
      const activities = store.get('activities') || [];
      activities.push(activity);

      const thirtyDaysAgo = Date.now() - 30 * 24 * 60 * 60 * 1000;
      const filtered = activities.filter(a => new Date(a.startTime).getTime() > thirtyDaysAgo);
      store.set('activities', filtered);

      // ✅ Always read latest settings here
      const latestSettings = store.get('settings') || {};
      const syncEnabled =
        latestSettings.syncEnabled ?? latestSettings.autoSyncEnabled ?? false;

      if (syncEnabled) {
        const syncQueue = store.get('syncQueue') || [];
        syncQueue.push(activity);
        store.set('syncQueue', syncQueue);
      }

      if (mainWindow?.webContents) {
        mainWindow.webContents.send('activity-logged', activity);
      }
    },

    onIdleStart: () => {
      if (mainWindow?.webContents) mainWindow.webContents.send('idle-started');
      handleIdleSync();
    },

    onIdleEnd: (idleDuration) => {
      if (mainWindow?.webContents) mainWindow.webContents.send('idle-ended', idleDuration);
      handleIdleEnd();
    },

    onStatusChange: (status) => {
      if (mainWindow?.webContents) mainWindow.webContents.send('tracking-status-changed', status);
      updateTrayMenu();
    }
  });

  if (settings.trackingEnabled) {
    setTimeout(() => tracker?.start(), 2000);
  }
}

// -----------------------------
// ✅ Supabase Edge Function Sync (FIXED)
// -----------------------------
async function syncActivities() {
  const settings = store.get('settings');

  if (!settings.syncEnabled || !settings.syncUrl || !settings.syncToken) {
    return { success: false, error: 'Sync not configured' };
  }

  const anonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1ma3ZiYXVpaXJ4dnJzZ2tpenR6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY5MzUxNTAsImV4cCI6MjA4MjUxMTE1MH0.2H-8kPyZ1GVSBbvF8Ua8if1cdGTQSrTVTZm_PnPROEw';
  if (!anonKey) {
    return { success: false, error: 'Missing Supabase anon key (SUPABASE_ANON_KEY or settings.syncAnonKey)' };
  }

  const syncQueue = store.get('syncQueue') || [];
  if (syncQueue.length === 0) return { success: true, synced: 0 };

  const deviceId = getDeviceId();
  const baseUrl = settings.syncUrl.replace(/\/$/, '');

  try {
    const response = await fetch(`${baseUrl}/functions/v1/desktop-sync`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-sync-token': settings.syncToken,
        'x-device-id': deviceId,

        // REQUIRED for Supabase Edge Functions gateway
        'Authorization': `Bearer ${anonKey}`,
        'apikey': anonKey
      },
      body: JSON.stringify({
        activities: syncQueue.map(a => ({
          id: a.id || null,
          applicationName: a.applicationName,
          windowTitle: a.windowTitle || '',
          startTime: a.startTime,
          endTime: a.endTime,
          duration: a.duration,
          projectId: a.projectId || null,
          taskId: a.taskId || null,
          isCoded: a.isCoded || false,
          isIdle: a.isIdle || false,
          categoryId: a.categoryId || null,
          categoryAutoAssigned: a.categoryAutoAssigned || false
        })),
        deviceId,
        deviceName: os.hostname(),
        platform: process.platform,
        timestamp: new Date().toISOString(),
        syncType: 'push'
      })
    });

    const text = await response.text();
    let result = {};
    try { result = text ? JSON.parse(text) : {}; } catch { result = { raw: text }; }

    if (!response.ok) {
      const msg = result?.error || result?.message || text || `HTTP ${response.status}`;
      throw new Error(msg);
    }

    // Success
    store.set('syncQueue', []);
    store.set('lastSyncTime', new Date().toISOString());

    if (mainWindow?.webContents) {
      mainWindow.webContents.send('sync-completed', {
        success: true,
        synced: result.syncedCount || syncQueue.length,
        syncId: result.syncId
      });
    }

    return { success: true, synced: result.syncedCount || syncQueue.length };
  } catch (error) {
    console.error('Sync error:', error);
    if (mainWindow?.webContents) mainWindow.webContents.send('sync-completed', { success: false, error: error.message });
    return { success: false, error: error.message };
  }
}

// -----------------------------
// IPC handlers (match preload.js)
// -----------------------------
function setupIpcHandlers() {
  ipcMain.handle('get-activities', () => store.get('activities') || []);
  ipcMain.handle('get-today-activities', () => {
    const activities = store.get('activities') || [];
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    return activities.filter(a => new Date(a.startTime) >= today);
  });

  ipcMain.handle('get-settings', () => store.get('settings'));

  ipcMain.handle('update-settings', (event, newSettings) => {
    const current = store.get('settings');
    const updated = {
      ...current,
      ...newSettings,
      idleThreshold: Number(newSettings.idleThreshold ?? current.idleThreshold ?? 300),
      minActivityDuration: Number(newSettings.minActivityDuration ?? current.minActivityDuration ?? 60),
      switchDebounceSeconds: Number(newSettings.switchDebounceSeconds ?? current.switchDebounceSeconds ?? 7),
      excludeApps: Array.isArray(newSettings.excludeApps) ? newSettings.excludeApps : (current.excludeApps ?? []),
      excludeTitles: Array.isArray(newSettings.excludeTitles) ? newSettings.excludeTitles : (current.excludeTitles ?? [])
    };
    store.set('settings', updated);

    if (tracker?.updateSettings) {
    tracker.updateSettings({
      idleThreshold: updated.idleThreshold,
      minActivityDuration: updated.minActivityDuration,
      switchDebounceSeconds: updated.switchDebounceSeconds,
      excludeApps: updated.excludeApps,
      excludeTitles: updated.excludeTitles,
      pollInterval: updated.pollInterval,
      autoCategorize: updated.autoCategorize
    });
    }

    // restart timer if sync settings changed
    startAutoSyncTimer();
    return updated;
  });

  ipcMain.handle('start-tracking', () => {
    tracker?.start?.();
    return true;
  });

  ipcMain.handle('pause-tracking', () => {
    tracker?.pause?.();
    return true;
  });

  ipcMain.handle('get-tracking-status', () => ({
    isTracking: tracker ? tracker.isTracking : false,
    currentActivity: tracker?.getCurrentActivity?.() || null,
    stats: tracker?.getStats?.() || null
  }));

  ipcMain.handle('sync-activities', async () => await syncActivities());

  ipcMain.handle('get-sync-status', () => {
    const s = store.get('settings');
    const q = store.get('syncQueue') || [];
    return {
      enabled: s.syncEnabled,
      configured: !!(s.syncUrl && s.syncToken),
      pendingCount: q.length,
      lastSyncTime: store.get('lastSyncTime')
    };
  });

  ipcMain.handle('generate-sync-token', () => uuidv4() + '-' + Date.now().toString(36));

  ipcMain.handle('get-device-info', () => ({
    deviceId: getDeviceId(),
    platform: process.platform,
    arch: process.arch,
    version: app.getVersion()
  }));

  ipcMain.handle('window-minimize', () => mainWindow?.minimize());
  ipcMain.handle('window-close', () => mainWindow?.close());

  ipcMain.handle('open-external', (event, url) => {
    if (/^https?:\/\//i.test(url)) shell.openExternal(url);
  });

  ipcMain.handle('get-release-url', () => 'https://github.com/timetracker/timetracker-desktop/releases');

  // updater passthroughs (if your updater implements them)
  ipcMain.handle('check-for-updates', () => appUpdater?.checkForUpdates?.(false) || null);
  ipcMain.handle('download-update', () => appUpdater?.downloadUpdate?.() || null);
  ipcMain.handle('install-update', () => appUpdater?.installUpdate?.() || null);
  ipcMain.handle('get-update-status', () => appUpdater?.getStatus?.() || null);
  ipcMain.handle('get-app-version', () => app.getVersion());
  ipcMain.handle('set-auto-download', (e, enabled) => appUpdater?.setAutoDownload?.(enabled) || null);
  ipcMain.handle('set-allow-prerelease', (e, enabled) => {
    const current = store.get('settings');
    store.set('settings', { ...current, allowPrerelease: !!enabled });
    if (appUpdater?.setAllowPrerelease) appUpdater.setAllowPrerelease(!!enabled);
    return true;
  });
}

// Power monitor events (keep)
function setupPowerMonitor() {
  powerMonitor.on('suspend', () => tracker?.handleSuspend?.());
  powerMonitor.on('resume', () => tracker?.handleResume?.());
  powerMonitor.on('lock-screen', () => tracker?.handleLock?.());
  powerMonitor.on('unlock-screen', () => tracker?.handleUnlock?.());
}

// -----------------------------
// App lifecycle
// -----------------------------
app.whenReady().then(async () => {
  createWindow();
  createTray();
  setupIpcHandlers();
  await initializeTracker();
  setupPowerMonitor();

  startAutoSyncTimer();
  syncOnStartup();

  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) createWindow();
  });
});

app.on('before-quit', async () => {
  isQuitting = true;
  stopAutoSyncTimer();
  await syncOnClose();
  tracker?.stop?.();
});

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    if (!store.get('settings.minimizeToTray')) app.quit();
  }
});

// Auto-start on boot (keep)
try {
  app.setLoginItemSettings({
    openAtLogin: store.get('settings.startOnBoot', true),
    openAsHidden: true
  });
} catch (e) {
  console.error('Failed to set login item settings:', e);
}

process.on('uncaughtException', (error) => console.error('Uncaught exception:', error));
process.on('unhandledRejection', (reason, promise) => console.error('Unhandled rejection at:', promise, 'reason:', reason));
